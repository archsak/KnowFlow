In statistics, an approximate entropy (ApEn) is a technique used to quantify the amount of regularity and the unpredictability of fluctuations over time-series data. For example, consider two series of data:
 Series A: (0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, ...), which alternates 0 and 1.

 Series B: (0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, ...), which has either a value of 0 or 1, chosen randomly, each with probability 1/2.

Moment statistics, such as mean and variance, will not distinguish between these two series. Nor will rank order statistics distinguish between these series. Yet series A is perfectly regular: knowing a term has the value of 1 enables one to predict with certainty that the next term will have the value of 0. In contrast, series B is randomly valued: knowing a term has the value of 1 gives no insight into what value the next term will have.

Regularity was originally measured by exact regularity statistics, which has mainly centered on various entropy measures.
However, accurate entropy calculation requires vast amounts of data, and the results will be greatly influenced by system noise, therefore it is not practical to apply these methods to experimental data. ApEn was first proposed (under a different name) by Aviad Cohen and Itamar Procaccia,
as an approximate algorithm to compute an exact regularity statistic, Kolmogorovâ€“Sinai entropy, and later popularized by Steve M. Pincus. ApEn was initially used to analyze chaotic dynamics and medical data, such as heart rate, and later spread its applications in finance, physiology, human factors engineering, and climate sciences.

Algorithm
A comprehensive step-by-step tutorial with an explanation of the theoretical foundations of Approximate Entropy is available. The algorithm is:

 Step 1 Assume a time series of data . These are  raw data values from measurements equally spaced in time.
 Step 2 Let  be a positive integer, with , which represents the length of a run of data (essentially a window).Let  be a positive real number, which specifies a filtering level.Let .
 Step 3 Define  for each  where . In other words,  is an -dimensional vector that contains the run of data starting with .Define the distance between two vectors  and  as the maximum of the distances between their respective components, given by
 
 for .
 Step 4 Define a count  as
 
 for each  where . Note that since  takes on all values between 1 and , the match will be counted when  (i.e. when the test subsequence, , is matched against itself, ).
 Step 5 Define
 
 where  is the natural logarithm, and for a fixed , , and  as set in Step 2.
 Step 6 Define approximate entropy () as

Parameter selection Typically, choose  or , whereas  depends greatly on the application.

An implementation on Physionet, which is based on Pincus, use  instead of  in Step 4. While a concern for artificially constructed examples, it is usually not a concern in practice.

Example
thumb|Illustration of the Heart Rate Sequence
Consider a sequence of  samples of heart rate equally spaced in time:

Note the sequence is periodic with a period of 3. Let's choose  and  (the values of  and  can be varied without affecting the result).

Form a sequence of vectors: 

Distance is calculated repeatedly as follows. In the first calculation,

 which is less than .

In the second calculation, note that , so

 which is greater than .
Similarly,

The result is a total of 17 terms  such that . These include . In these cases,  is

Note in Step 4,  for . So the terms  such that  include , and the total number is 16.

At the end of these calculations, we have

Then we repeat the above steps for . First form a sequence of vectors: 

By calculating distances between vector , we find the vectors satisfying the filtering level have the following characteristic:

Therefore,  

At the end of these calculations, we have

Finally,

The value is very small, so it implies the sequence is regular and predictable, which is consistent with the observation.

Python implementation
import math

def approx_entropy(time_series, run_length, filter_level) -> float:
    """
    Approximate entropy

    >>> import random
    >>> regularly = [85, 80, 89] * 17
    >>> print(f"{approx_entropy(regularly, 2, 3):e}")
    1.099654e-05
    >>> randomly = [random.choice([85, 80, 89]) for _ in range(17*3)]
    >>> 0.8 < approx_entropy(randomly, 2, 3) < 1
    True
    """

    def _maxdist(x_i, x_j):
        return max(abs(ua - va) for ua, va in zip(x_i, x_j))

    def _phi(m):
        n = time_series_length - m + 1
        x = [
            [time_series[j] for j in range(i, i + m - 1 + 1)]
            for i in range(time_series_length - m + 1)
        ]
        counts = [
            sum(1 for x_j in x if _maxdist(x_i, x_j) <= filter_level) / n for x_i in x
        ]
        return sum(math.log(c) for c in counts) / n

    time_series_length = len(time_series)

    return abs(_phi(run_length + 1) - _phi(run_length))

if __name__ == "__main__":
    import doctest

    doctest.testmod()

MATLAB implementation
 Fast Approximate Entropy from MatLab Central
 approximateEntropy

Interpretation
The presence of repetitive patterns of fluctuation in a time series renders it more predictable than a time series in which such patterns are absent. ApEn reflects the likelihood that similar patterns of observations will not be followed by additional similar observations. A time series containing many repetitive patterns has a relatively small ApEn; a less predictable process has a higher ApEn.

Advantages
The advantages of ApEn include:
Lower computational demand. ApEn can be designed to work for small data samples ( points) and can be applied in real time.
Less effect from noise. If data is noisy, the ApEn measure can be compared to the noise level in the data to determine what quality of true information may be present in the data.

Limitations
The ApEn algorithm counts each sequence as matching itself to avoid the occurrence of  in the calculations. This step might introduce bias in ApEn, which causes ApEn to have two poor properties in practice: 
 ApEn is heavily dependent on the record length and is uniformly lower than expected for short records. 
 It lacks relative consistency. That is, if ApEn of one data set is higher than that of another, it should, but does not, remain higher for all conditions tested.

Applications
ApEn has been applied to classify electroencephalography (EEG) in psychiatric diseases, such as schizophrenia, epilepsy, and addiction.